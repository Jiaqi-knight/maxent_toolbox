
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>maxent_example</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-07-24"><meta name="DC.source" content="maxent_example.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">part 1: working with small distributions of neurons (exhaustively)</a></li><li><a href="#3">part 2: working with larger distributions of neurons (MCMC)</a></li><li><a href="#4">part 3: working with MERP distributions of neurons</a></li></ul></div><pre class="codeinput"><span class="comment">% Example code for the maximum entropy toolkit</span>
<span class="comment">% Ori Maoz, July 2016:  orimaoz@gmail.com,</span>
</pre><h2>part 1: working with small distributions of neurons (exhaustively)<a name="2"></a></h2><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15</span>

<span class="comment">% randomly divide it into a training set and a test set (so we can verify how well we trained)</span>
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

<span class="comment">% create a k-ising model (pairwise maxent with synchrony constraints)</span>
model = createModel(ncells,<span class="string">'kising'</span>);

<span class="comment">% train the model to a threshold of one standard deviation from the error of computing the marginals.</span>
<span class="comment">% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states</span>
<span class="comment">% in memory and train the model in an exhaustive fashion.</span>
model = trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);

model_entropy = getEntropy(model);
fprintf(<span class="string">'Model entropy: %.03f   empirical dataset entropy: %.03f\n'</span>, getEntropy(model), empirical_distribution.entropy);

<span class="comment">% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions</span>
marginals_data = getEmpiricalMarginals(samples_test,model);
marginals_model = getMarginals(model);

<span class="comment">% plot them on a log scale</span>
figure
loglog(marginals_data,marginals_model,<span class="string">'b*'</span>);
hold <span class="string">on</span>;
minval = min([marginals_data(marginals_data&gt;0)]);
plot([minval 1],[minval 1],<span class="string">'-r'</span>); <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical marginal'</span>);
ylabel(<span class="string">'predicted marginal'</span>);
title(sprintf(<span class="string">'marginals in %d cells'</span>,ncells));
</pre><pre class="codeoutput">Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
166/Inf  MSE=0.009 (mean), 2.080 (max) [9]  DKL: 0.098
converged (marginals match)
Standard deviations from marginals: 0.085 (mean), 0.979 (max) [9]  DKL: 0.098
Kullback-Leibler divergence from test set: 0.101534
Model entropy: 6.486   empirical dataset entropy: 6.359
</pre><img vspace="5" hspace="5" src="maxent_example_01.png" style="width:560px;height:420px;" alt=""> <h2>part 2: working with larger distributions of neurons (MCMC)<a name="3"></a></h2><pre class="codeinput">load <span class="string">example50</span>

<span class="comment">% randomly divide into train/test sets</span>
[ncells,nsamples] = size(spikes50);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes50(:,idx_train);
samples_test = spikes50(:,idx_test);

<span class="comment">% create an ising model (pairwise maxent)</span>
model = createModel(50,<span class="string">'ising'</span>);

<span class="comment">% train the model to a threshold of 1.5 standard deviations from the error of computing the marginals.</span>
<span class="comment">% because the distribution is larger (50 dimensions) we cannot explicitly iterate over all 5^20 states</span>
<span class="comment">% in memory and will use markov chain monte carlo (MCMC) methods to obtain an approximation</span>
model = trainModel(model,samples_train,<span class="string">'threshold'</span>,1.5);


<span class="comment">% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions.</span>
<span class="comment">% here the model marginals could not be computed exactly so they will be estimated using monte-carlo. We specify the</span>
<span class="comment">% number of samples we use so that their estimation will have the same amoutn noise as the empirical marginal values</span>
marginals_data = getEmpiricalMarginals(samples_test,model);
marginals_model = getMarginals(model,<span class="string">'nsamples'</span>,size(samples_test,2));

<span class="comment">% plot them on a log scale</span>
figure
loglog(marginals_data,marginals_model,<span class="string">'b*'</span>);
hold <span class="string">on</span>;
minval = min([marginals_data(marginals_data&gt;0)]);
plot([minval 1],[minval 1],<span class="string">'-r'</span>); <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical marginal'</span>);
ylabel(<span class="string">'predicted marginal'</span>);
title(sprintf(<span class="string">'marginals in %d cells'</span>,ncells));

<span class="comment">% the model that the MCMC solver returns is not normalized. If we want to compare the predicted and actual probabilities</span>
<span class="comment">% of individual firing patterns, we will need to first normalize the model. We will use the wang-landau algorithm for</span>
<span class="comment">% this. We chose parameters which are less strict than the default settings so that we will have a faster runtime.</span>
disp(<span class="string">'Normalizing model...'</span>);
model = wangLandau(model,<span class="string">'binsize'</span>,0.1,<span class="string">'depth'</span>,15);

<span class="comment">% the normalization factor was added to the model structure. Now that we have a normalized model, we'll use it to</span>
<span class="comment">% predict the frequency of activity patterns. We will start by observing all the patterns that repeated at least twice</span>
<span class="comment">% (because a pattern that repeated at least once may grossly overrepresent its probability and is not meaningful in this</span>
<span class="comment">% sort of analysis)</span>
limited_empirical_distribution = getEmpiricalModel(samples_test,<span class="string">'min_count'</span>,2);


<span class="comment">% get the model predictions for these patterns</span>
model_logprobs = getLogProbability(model,limited_empirical_distribution.words);

<span class="comment">% nplot on a log scale</span>
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,<span class="string">'bo'</span>);
hold <span class="string">on</span>;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],<span class="string">'-r'</span>);  <span class="comment">% identity line</span>
xlabel(<span class="string">'empirical pattern log frequency'</span>);
ylabel(<span class="string">'predicted pattern log frequency'</span>);
title(sprintf(<span class="string">'activity pattern frequency in %d cells'</span>,ncells));



<span class="comment">% Wang-landau also approximated the model entropy, let's compare it to the entropy of the empirical dataset.</span>
<span class="comment">% for this we want to look at the entire set, not just the set limited repeating patterns</span>
empirical_distribution = getEmpiricalModel(samples_test);

<span class="comment">% it will not be surprising to see that the empirical entropy is much lower than the model, this is because the</span>
<span class="comment">% distribution is very undersampled</span>
fprintf(<span class="string">'Model entropy: %.03f bits, empirical entropy (test set): %.03f bits\n'</span>,model.entropy,empirical_distribution.entropy);

<span class="comment">% generate samples from the distribution and compute their entropy. This should give a result which is must closer to</span>
<span class="comment">% the entropy of the empirical distribution...</span>
samples_simulated = generateSamples(model,numel(idx_test));
simulated_empirical_distribution = getEmpiricalModel(samples_simulated);
fprintf(<span class="string">'Entropy of simulated data: %.03f bits\n'</span>,simulated_empirical_distribution.entropy);
</pre><pre class="codeoutput">Training to threshold: 1.500 standard deviations
Maximum samples: 17778   maximum MSE: 3.375
334/Inf samples=4167  MSE=7.604 (mean), 61.004 (max) [30]
403/Inf samples=8328  MSE=4.055 (mean), 62.576 (max) [45]
444/Inf samples=12544  MSE=3.418 (mean), 52.889 (max) [2]
473/Inf samples=16755  MSE=2.762 (mean), 71.485 (max) [2]
497/Inf samples=17778  MSE=2.047 (mean), 39.743 (max) [2]
521/Inf samples=17778  MSE=1.833 (mean), 36.491 (max) [12]
545/Inf samples=17778  MSE=1.746 (mean), 28.431 (max) [12]
569/Inf samples=17778  MSE=1.586 (mean), 15.138 (max) [45]
593/Inf samples=17778  MSE=1.674 (mean), 11.126 (max) [45]
617/Inf samples=17778  MSE=1.700 (mean), 11.267 (max) [31]
641/Inf samples=17778  MSE=1.730 (mean), 10.157 (max) [410]
665/Inf samples=17778  MSE=1.709 (mean), 10.810 (max) [1166]
689/Inf samples=17778  MSE=1.856 (mean), 10.223 (max) [398]
713/Inf samples=17778  MSE=1.736 (mean), 8.511 (max) [1069]
737/Inf samples=17778  MSE=1.431 (mean), 6.374 (max) [40]
761/Inf samples=17778  MSE=1.395 (mean), 7.260 (max) [12]
785/Inf samples=17778  MSE=1.402 (mean), 8.547 (max) [12]
809/Inf samples=17778  MSE=1.431 (mean), 6.519 (max) [12]
833/Inf samples=17778  MSE=1.442 (mean), 4.455 (max) [1135]
857/Inf samples=17778  MSE=1.363 (mean), 5.526 (max) [590]
881/Inf samples=17778  MSE=1.388 (mean), 7.051 (max) [590]
905/Inf samples=17778  MSE=1.396 (mean), 5.593 (max) [608]
929/Inf samples=17778  MSE=1.412 (mean), 5.293 (max) [590]
953/Inf samples=17778  MSE=1.414 (mean), 6.070 (max) [590]
977/Inf samples=17778  MSE=1.338 (mean), 5.592 (max) [590]
1001/Inf samples=17778  MSE=1.377 (mean), 5.249 (max) [590]
1025/Inf samples=17778  MSE=1.347 (mean), 4.704 (max) [291]
1049/Inf samples=17778  MSE=1.275 (mean), 3.863 (max) [291]
converged (marginals match)
Normalizing model...
[...............]
Elapsed time is 6.138243 seconds.
Model entropy: 17.468 bits, empirical entropy (test set): 11.964 bits
Entropy of simulated data: 12.422 bits
</pre><img vspace="5" hspace="5" src="maxent_example_02.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="maxent_example_03.png" style="width:560px;height:420px;" alt=""> <h2>part 3: working with MERP distributions of neurons<a name="4"></a></h2><pre class="codeinput"><span class="comment">% load spiking data of 15 neurons</span>
load <span class="string">example15</span>

<span class="comment">% randomly divide it into a training set and a test set (so we can verify how well we trained)</span>
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

<span class="comment">% create a MERP model with default settings</span>
model = createModel(ncells,<span class="string">'merp'</span>);

<span class="comment">% train the model to a threshold of one standard deviation from the error of computing the marginals.</span>
<span class="comment">% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states</span>
<span class="comment">% in memory and train the model in an exhaustive fashion.</span>
model = trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);

<span class="comment">% create a MERP model with a specified number of projections and specified sparsity</span>
model = createModel(ncells,<span class="string">'merp'</span>,<span class="string">'nprojections'</span>,300,<span class="string">'sparsity'</span>,0.5);

<span class="comment">% train the model</span>
model = trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);


<span class="comment">% normalize the MERP model threshold so that the moment-generating function will give us a requested average value:</span>
model = normalizeMerpThreshold(model,samples_train);

<span class="comment">% retrain it</span>
model = trainModel(model,samples_train,<span class="string">'threshold'</span>,1);

<span class="comment">% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set</span>
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf(<span class="string">'Kullback-Leibler divergence from test set: %f\n'</span>,test_dkl);
</pre><pre class="codeoutput">Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
58/Inf  MSE=0.142 (mean), 42.035 (max) [105]  DKL: 0.135
122/Inf  MSE=0.022 (mean), 18.743 (max) [105]  DKL: 0.120
187/Inf  MSE=0.006 (mean), 3.279 (max) [105]  DKL: 0.115
converged (marginals match)
Standard deviations from marginals: 0.051 (mean), 1.000 (max) [105]  DKL: 0.113
Kullback-Leibler divergence from test set: 0.108762
Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
20/Inf  MSE=8.560 (mean), 1288.721 (max) [117]  DKL: 0.280
51/Inf  MSE=0.719 (mean), 160.287 (max) [117]  DKL: 0.168
82/Inf  MSE=0.143 (mean), 25.819 (max) [37]  DKL: 0.144
113/Inf  MSE=0.061 (mean), 18.505 (max) [37]  DKL: 0.132
144/Inf  MSE=0.031 (mean), 20.212 (max) [117]  DKL: 0.125
175/Inf  MSE=0.016 (mean), 10.818 (max) [117]  DKL: 0.121
206/Inf  MSE=0.010 (mean), 5.550 (max) [117]  DKL: 0.117
237/Inf  MSE=0.007 (mean), 4.562 (max) [117]  DKL: 0.115
268/Inf  MSE=0.006 (mean), 3.668 (max) [117]  DKL: 0.113
299/Inf  MSE=0.003 (mean), 2.417 (max) [117]  DKL: 0.112
330/Inf  MSE=0.002 (mean), 1.623 (max) [117]  DKL: 0.111
361/Inf  MSE=0.002 (mean), 1.425 (max) [117]  DKL: 0.110
392/Inf  MSE=0.001 (mean), 1.198 (max) [117]  DKL: 0.109
converged (marginals match)
Standard deviations from marginals: 0.036 (mean), 0.999 (max) [117]  DKL: 0.109
Kullback-Leibler divergence from test set: 0.114417
....................
Training to threshold: 1.000 standard deviations
Maximum MSE: 1.000
18/Inf  MSE=3.131 (mean), 146.153 (max) [183]  DKL: 0.227
45/Inf  MSE=0.236 (mean), 6.694 (max) [81]  DKL: 0.152
72/Inf  MSE=0.090 (mean), 4.783 (max) [81]  DKL: 0.132
99/Inf  MSE=0.036 (mean), 1.460 (max) [79]  DKL: 0.122
converged (marginals match)
Standard deviations from marginals: 0.171 (mean), 0.980 (max) [167]  DKL: 0.120
Kullback-Leibler divergence from test set: 0.122900
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
% Example code for the maximum entropy toolkit
% Ori Maoz, July 2016:  orimaoz@gmail.com,


%% part 1: working with small distributions of neurons (exhaustively)

% load spiking data of 15 neurons
load example15

% randomly divide it into a training set and a test set (so we can verify how well we trained)
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

% create a k-ising model (pairwise maxent with synchrony constraints)
model = createModel(ncells,'kising');

% train the model to a threshold of one standard deviation from the error of computing the marginals.
% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states 
% in memory and train the model in an exhaustive fashion.
model = trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);

model_entropy = getEntropy(model);
fprintf('Model entropy: %.03f   empirical dataset entropy: %.03f\n', getEntropy(model), empirical_distribution.entropy);

% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions
marginals_data = getEmpiricalMarginals(samples_test,model);
marginals_model = getMarginals(model);

% plot them on a log scale
figure
loglog(marginals_data,marginals_model,'b*');
hold on;
minval = min([marginals_data(marginals_data>0)]);
plot([minval 1],[minval 1],'-r'); % identity line
xlabel('empirical marginal');
ylabel('predicted marginal');
title(sprintf('marginals in %d cells',ncells));


%% part 2: working with larger distributions of neurons (MCMC)

load example50

% randomly divide into train/test sets
[ncells,nsamples] = size(spikes50);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes50(:,idx_train);
samples_test = spikes50(:,idx_test);

% create an ising model (pairwise maxent)
model = createModel(50,'ising');

% train the model to a threshold of 1.5 standard deviations from the error of computing the marginals.
% because the distribution is larger (50 dimensions) we cannot explicitly iterate over all 5^20 states 
% in memory and will use markov chain monte carlo (MCMC) methods to obtain an approximation
model = trainModel(model,samples_train,'threshold',1.5);


% get the marginals (firing rates and correlations) of the test data and see how they compare to the model predictions.
% here the model marginals could not be computed exactly so they will be estimated using monte-carlo. We specify the
% number of samples we use so that their estimation will have the same amoutn noise as the empirical marginal values
marginals_data = getEmpiricalMarginals(samples_test,model);
marginals_model = getMarginals(model,'nsamples',size(samples_test,2));

% plot them on a log scale
figure
loglog(marginals_data,marginals_model,'b*');
hold on;
minval = min([marginals_data(marginals_data>0)]);
plot([minval 1],[minval 1],'-r'); % identity line
xlabel('empirical marginal');
ylabel('predicted marginal');
title(sprintf('marginals in %d cells',ncells));

% the model that the MCMC solver returns is not normalized. If we want to compare the predicted and actual probabilities
% of individual firing patterns, we will need to first normalize the model. We will use the wang-landau algorithm for
% this. We chose parameters which are less strict than the default settings so that we will have a faster runtime.
disp('Normalizing model...');
model = wangLandau(model,'binsize',0.1,'depth',15);

% the normalization factor was added to the model structure. Now that we have a normalized model, we'll use it to
% predict the frequency of activity patterns. We will start by observing all the patterns that repeated at least twice
% (because a pattern that repeated at least once may grossly overrepresent its probability and is not meaningful in this
% sort of analysis)
limited_empirical_distribution = getEmpiricalModel(samples_test,'min_count',2);


% get the model predictions for these patterns
model_logprobs = getLogProbability(model,limited_empirical_distribution.words);

% nplot on a log scale
figure
plot(limited_empirical_distribution.logprobs,model_logprobs,'bo');
hold on;
minval = min(limited_empirical_distribution.logprobs);
plot([minval 0],[minval 0],'-r');  % identity line
xlabel('empirical pattern log frequency');
ylabel('predicted pattern log frequency');
title(sprintf('activity pattern frequency in %d cells',ncells));



% Wang-landau also approximated the model entropy, let's compare it to the entropy of the empirical dataset.
% for this we want to look at the entire set, not just the set limited repeating patterns
empirical_distribution = getEmpiricalModel(samples_test);

% it will not be surprising to see that the empirical entropy is much lower than the model, this is because the
% distribution is very undersampled
fprintf('Model entropy: %.03f bits, empirical entropy (test set): %.03f bits\n',model.entropy,empirical_distribution.entropy);

% generate samples from the distribution and compute their entropy. This should give a result which is must closer to
% the entropy of the empirical distribution...
samples_simulated = generateSamples(model,numel(idx_test));
simulated_empirical_distribution = getEmpiricalModel(samples_simulated);
fprintf('Entropy of simulated data: %.03f bits\n',simulated_empirical_distribution.entropy);



%% part 3: working with MERP distributions of neurons

% load spiking data of 15 neurons
load example15

% randomly divide it into a training set and a test set (so we can verify how well we trained)
[ncells,nsamples] = size(spikes15);
idx_train = randperm(nsamples,ceil(nsamples/2));
idx_test = setdiff(1:nsamples,idx_train);
samples_train = spikes15(:,idx_train);
samples_test = spikes15(:,idx_test);

% create a MERP model with default settings
model = createModel(ncells,'merp');

% train the model to a threshold of one standard deviation from the error of computing the marginals.
% because the distribution is relatively small (15 dimensions) we can explicitly represent all 2^15 states 
% in memory and train the model in an exhaustive fashion.
model = trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);

% create a MERP model with a specified number of projections and specified sparsity
model = createModel(ncells,'merp','nprojections',300,'sparsity',0.5);

% train the model
model = trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);


% normalize the MERP model threshold so that the moment-generating function will give us a requested average value:
model = normalizeMerpThreshold(model,samples_train);

% retrain it
model = trainModel(model,samples_train,'threshold',1);

% now check the kullback-leibler divergence between the model predictions and the pattern counts in the test-set 
empirical_distribution = getEmpiricalModel(samples_test);
model_logprobs = getLogProbability(model,empirical_distribution.words);
test_dkl = dkl(empirical_distribution.logprobs,model_logprobs);
fprintf('Kullback-Leibler divergence from test set: %f\n',test_dkl);




##### SOURCE END #####
--></body></html>